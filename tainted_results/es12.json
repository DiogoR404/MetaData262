[{"path":"test/built-ins/FinalizationRegistry/gc-has-one-chance-to-call-cleanupCallback.js","esid":" sec-finalization-registry-target","description":" >cleanupCallback has only one optional chance to be called for a GC that cleans up\na registered target.\n","info":" |FinalizationRegistry ( cleanupCallback )\n\nFinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n...\n4. If callback is not undefined and IsCallable(callback) is false, throw a TypeError exception.\n5. Perform ? CleanupFinalizationRegistry(finalizationRegistry, callback).\n6. Return undefined.\n\nExecution\n\nAt any time, if an object obj is not live, an ECMAScript implementation may perform the following steps atomically:\n\n1. For each WeakRef ref such that ref.[[Target]] is obj,\na. Set ref.[[Target]] to empty.\n2. For each FinalizationRegistry finalizationRegistry such that finalizationRegistry.[[Cells]] contains cell, such that cell.[[Target]] is obj,\na. Set cell.[[Target]] to empty.\nb. Optionally, perform ! HostCleanupFinalizationRegistry(finalizationRegistry).\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","async-functions","host-gc-required"],"flags":["async","non-deterministic"],"includes":["async-gc.js","compareArray.js"]},{"path":"test/built-ins/FinalizationRegistry/prototype/cleanupSome/cleanup-prevented-with-reference.js","esid":" sec-finalization-registry.prototype.cleanupSome","description":" Cleanup might be prevented with a reference usage;","info":" |FinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n1. Let finalizationRegistry be the this value.\n2. If Type(finalizationRegistry) is not Object, throw a TypeError exception.\n3. If finalizationRegistry does not have a [[Cells]] internal slot, throw a TypeError exception.\n4. If callback is not undefined and IsCallable(callback) is false, throw a TypeError exception.\n5. Perform ? CleanupFinalizationRegistry(finalizationRegistry, callback).\n6. Return undefined.\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]},{"path":"test/built-ins/FinalizationRegistry/prototype/cleanupSome/cleanup-prevented-with-unregister.js","esid":" sec-finalization-registry.prototype.cleanupSome","description":" Cleanup might be prevented with an unregister usage","info":" |FinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n1. Let finalizationRegistry be the this value.\n2. If Type(finalizationRegistry) is not Object, throw a TypeError exception.\n3. If finalizationRegistry does not have a [[Cells]] internal slot, throw a TypeError exception.\n4. If callback is not undefined and IsCallable(callback) is false, throw a TypeError exception.\n5. Perform ? CleanupFinalizationRegistry(finalizationRegistry, callback).\n6. Return undefined.\n\nFinalizationRegistry.prototype.unregister ( unregisterToken )\n\n1. Let removed be false.\n2. For each Record { [[Target]], [[Holdings]], [[UnregisterToken]] } cell that is an element of finalizationRegistry.[[Cells]], do\na. If SameValue(cell.[[UnregisterToken]], unregisterToken) is true, then\ni. Remove cell from finalizationRegistry.[[Cells]].\nii. Set removed to true.\n3. Return removed.\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]},{"path":"test/built-ins/FinalizationRegistry/prototype/cleanupSome/holdings-multiple-values.js","esid":" sec-properties-of-the-finalization-registry-constructor","description":" >Iterates over different type values in holdings\n","info":" |FinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n1. Let finalizationRegistry be the this value.\n...\n5. Perform ! CleanupFinalizationRegistry(finalizationRegistry, callback).\n...\n\nCleanupFinalizationRegistry ( finalizationRegistry [ , callback ] )\n\n...\n3. While finalizationRegistry.[[Cells]] contains a Record cell such that cell.[[WeakRefTarget]] is ~empty~, then an implementation may perform the following steps,\na. Choose any such cell.\nb. Remove cell from finalizationRegistry.[[Cells]].\nc. Perform ? Call(callback, undefined, << cell.[[HeldValue]] >>).\n...\n\n\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","Symbol","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]},{"path":"test/built-ins/FinalizationRegistry/prototype/cleanupSome/reentrancy.js","esid":" sec-properties-of-the-finalization-registry-constructor","description":" >The cleanupSome() method can be reentered\n","info":" |FinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]},{"path":"test/built-ins/FinalizationRegistry/prototype/unregister/unregister-cleaned-up-cell.js","esid":" sec-finalization-registry.prototype.unregister","description":" Cannot unregister a cell that has been cleaned up","info":" |FinalizationRegistry.prototype.cleanupSome ( [ callback ] )\n\n1. Let finalizationRegistry be the this value.\n...\n5. Perform ! CleanupFinalizationRegistry(finalizationRegistry, callback).\n...\n\nCleanupFinalizationRegistry ( finalizationRegistry [ , callback ] )\n\n...\n3. While finalizationRegistry.[[Cells]] contains a Record cell such that cell.[[WeakRefTarget]] is ~empty~, then an implementation may perform the following steps,\na. Choose any such cell.\nb. Remove cell from finalizationRegistry.[[Cells]].\nc. Perform ? Call(callback, undefined, << cell.[[HeldValue]] >>).\n...\n\nFinalizationRegistry.prototype.unregister ( unregisterToken )\n\n1. Let removed be false.\n2. For each Record { [[Target]], [[Holdings]], [[UnregisterToken]] } cell that is an element of finalizationRegistry.[[Cells]], do\na. If SameValue(cell.[[UnregisterToken]], unregisterToken) is true, then\ni. Remove cell from finalizationRegistry.[[Cells]].\nii. Set removed to true.\n3. Return removed.\n","features":["FinalizationRegistry.prototype.cleanupSome","FinalizationRegistry","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]},{"path":"test/built-ins/WeakRef/prototype/deref/gc-cleanup-not-prevented-with-wr-deref.js","esid":" sec-weak-ref.prototype.deref","description":" WeakRef deref should not prevent a GC event","info":" |WeakRef.prototype.deref ( )\n\n...\n4. Let target be the value of weakRef.[[Target]].\n5. If target is not empty,\na. Perform ! KeepDuringJob(target).\nb. Return target.\n6. Return undefined.\n","features":["FinalizationRegistry.prototype.cleanupSome","WeakRef","host-gc-required"],"includes":["async-gc.js"],"flags":["async","non-deterministic"]}]